"""
Внесите 12 правок в свои комментарии, дополнительно указывая,
по какому из вышеприведённых пунктов была сделана та или иная правка.
"""
# 1
# Представление намерений
# Задача о сумме дву чисел, выраженных связными списками (№ 2 на литкоде)
# Суть решения сводится к сложению "столбиком", при этом применяется
# дополнительная переменная "в уме", в которую сохраняем старший разряд
# при переполнении младшего

def addTwoNumbers(l1, l2):
    cur1 = l1
    cur2 = l2
    __Res = ListNode()
    current = __Res
    # дополнительная переменная "в уме", в нее будем сохранять старший разряд
    # при переполнении младшего
    mind_value = 0
    ...

# 2
# Представление намерений
# Задача о поиске самой длинной подстроки с уникальными (неповторяющимися)
# символами (Задача № 3 на Литкоде) 
# Решение логически неочевидно, поэтому я прокомментировал его

def lengthOfLongestSubstring(s):
    """ пробегаем по строке, начиная со второго символа
    если встретилась повторяющаяся буква
    заносим размер кусочка ДО ВТОРОЙ в паре ПОВТОРЯЮЩЕЙСЯ буквы в результаты
    и удаляем  кусочек до ПЕРВОЙ повторяющейся (ВКЛЮЧИТЕЛЬНО)
    если до конца строки повторов не встретилось
    заносим в ответы длину остатка """
    k = len(s)
    result = []
    while len(s) > 1:
        i = 1
        for current in s[1:]:
            if current in s[:i]:
                result.append(len(s[:i]))
                s = s[s.index(current)+1:]
                break
            elif i == len(s) - 1:
                result.append(len(s))
                s = s[:i]
            i += 1
    if len(s) == 1:
        result.append(1)
    if len(result) == 0:
        return k
    return max(result)

# 3
# Прояснение
# Задача Zigzag Conversion (№ 6 на Литкоде)
# Участки кода, которые содержат логику решения, снабжены комментариями

class Solution(object):
    def convert(self, s, numRows):
        """
        :type s: str
        :type numRows: int
        :rtype: str
        """
        if numRows == 1:
            return s
        
        matrix = []
        for i in range(numRows):        
            # Создаем матрицу для ответов
            matrix.append([])
        for i in range(len(s)):
            # пробегаем по строке, занося каждую букву в соотв. строку    
            if i % (2 * (numRows - 1)) < numRows:
            # для части которая идет вниз
                N = i % (2 * (numRows - 1))
            else:
            # для части которая идет вверх
                N = 2 * (numRows - 1) - i % (2 * (numRows - 1))
            matrix[N].append(s[i])
            
        for i in range(len(matrix)):
            matrix[i] = ''.join(matrix[i])
        return ''.join(matrix)

# Прояснение
# Задача "String to Integer (atoi)"  (№ 8 на Литкоде)
# Решние разделено на логические блоки (шаги)
# для понятности эти шаги предварены комментариями

# 4
def myAtoi(self, s: str) -> int:
    ...
    # Убираем ведущие пробелы
    Spases = True
    i = 0
    while Spases and i < len(s):
        if s[i] == ' ':
            i += 1
        else:
            Spases = False
    ...

# 5 (та же задача)
    ...
    # проверяем знак
    if s[i] == '+' or s[i] == '-':
        res.append(s[i])
        i += 1
    ...

# 6 (та же задача)
    ...
    # проверяем число
    while i < len(s):
        if s[i].isdigit():
            digits = True
            res.append(s[i])
            i += 1
        else:
            break
    ...

# 7 (та же задача) 
    ...
    # Анализируем цифры
    res = int(''.join(res))
    if res > 2 ** 31 - 1:
        res = 2 ** 31 - 1
    elif res < - (2 ** 31):
        res = - (2 ** 31)
    return res

# Прояснение
# Задача "threeSum"  (№ 15 на Литкоде)
# Решение разделено на логические блоки (шаги)
# Для иллюстрации логики решения эти шаги снабжены комментариями
# 8
class Solution:
    def threeSum(self, nums):
        res = []
        nums.sort()
        for i, n in enumerate(nums):
            print(i, n)

            #Find first element | avoid repetition
            if i>0 and n == nums[i - 1]:
                continue

# 9 Представление намерений (Та же задача)
# комментарии поясняют логику решения, которая сама по себе неочевидна
# Та же задача
            # Для остальной части массива устанавливаем указатели границ "левый" и "правый"   
            l, r = i+1, len(nums) - 1
            
            while l<r:
                s = n + nums[l] + nums[r]
# 10 
# Та же задача
                # Смещаем "окно" вправо, так что сумма увеличивается
                if s > 0:
                    r -= 1
# 11
# Та же задача

                # Для отрицательной суммы - смещаем "окно" влево, так что сумма уменьшается.
                elif s < 0:                     
                    l += 1           
# 12
# Та же задача
           
                # если сумма равна нулю, добавляем ее в список ответов
                else:
                    res.append([n,nums[l],nums[r]])     
                    l += 1
                    while nums[l] == nums[l-1] and l<r:
                        l += 1
        return res
