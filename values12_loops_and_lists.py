# Задание
# Приведите 5 примеров вашего кода,
# где вместо массивов можно использовать более безопасные структуры данных,
# или же работа с самими массивами может выполняться без их прямой индексации.

1
# Задача "экономия тонера" из курса 24 задачи
#  Задача решена следующим способом: все символы отранжированы по расходу
# тонера. Создан двумерный список, в котором первый эемент - расход,
# второй - коллекция символов, которые соответствуют этому расходу.


def PrintingCosts(Line):
    cod = []
    Cost = [0, ' ']
    cod.append(Cost)
    Cost = [3, '`', "'"]
    ...
    S = 0
    for i in range(len(Line)):
        N = 0
        for j in range(len(cod)):
            if Line[i] in cod[j]:
                N = cod[j][0]
        if N == 0 and Line[i] != ' ':
            N = 23
        S += N
    return S
# Так как в решении стоимость символа повторяться не должна,
# целесообрано заменить двумерный список на словарь, в котором
# ключи - это стоимость сомволов, а значение - коллекция символов,
# которые соответстуют этому расходу


def PrintingCosts1(Line):
    cod = {}
    cod[0] = [' ']
    cod[3] = ['`', "'"]
    ...
    S = 0
    for letter in range(len(Line)):
        N = 0
        for j in (cod):
            if letter in cod[j]:
                N = j
        if N == 0 and letter != ' ':
            N = 23
        S += N
    return S


2
# В этом же примере обращение к буквам текста по индексу заменено простым
# перебором букв в тексте.


3
# Задача о взломе мобильных телефонов (курс 24 задачи)
# После преобразований описан алгоритм избавления от нулей
# в конечной последовательности цифр


def PatternUnlock(N, hits):
    result = 0
    ...
    result = list(str(int(round(result, 5) * 100000)))
    for i in range(len(result)-1, -1, -1):
        if result[i] == '0':
            del result[i]
    S = ''.join(result)
    return S

# Такое решение неэффективно. так как del() для списка это затратная операция.
# Гораздо лучше просто пройти по списку слева направо
# и к итоговой строке прибавлять все ненулевые цифры


def PatternUnlock1(N, hits):
    result = 0
    result = list(str(int(round(result, 5) * 100000)))
    ...
    result2 = ''
    for digit in result:
        if digit != '0':
            result2 += str(digit)
    return result2


4
# Задача "Шопоголичка" из курса 24 задачи
# Суть задачи сводится к тому, что предварительно отсортированный список
# разбивается на 3х-элементные группы (в последней может быть меньше покупок)
# третий элемет каждой группы - берется по акции бесплатно.


def MaximumDiscount(N, price):
    Copy = sorted(price, reverse=True)
    discont = 0
    collection = []
    set_ = []
    for i in range(N):
        set_.append(Copy[i])
        if (i + 1) % 3 == 0:      # проверка размера коллекции set_
            collection.append(set_)
            set_ = []
    for i in range(len(collection)):
        discont += collection[i][2]
    return discont

# проверка размера коллекции set_ обращается непосредственно к индексу,
# при этом горадо проще обращаться к размеру получившейся группы
# if len(set_) == 3:


5
# В этой же задаче можно избавиться от дополнительного списка,
# просто каждый раз, когда коллекция  set_ получает третий элемент,
# его значение добавляется к переменной discont


def MaximumDiscount1(N, price):
    price.sort(reverse=True)
    discont = 0
    set_ = []
    for item in price:
        set_.append(item)
        if len(set_) == 3:
            discont += item
            set_ = []
    return discont
# таким образом, в решении ибавились от обращения к элементам списка по индексу
